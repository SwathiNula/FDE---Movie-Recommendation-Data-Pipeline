# -*- coding: utf-8 -*-
"""FDE (project final).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10btTcRwc2_M6jgRSHTPJLpvXR9CHkc9H
"""

# ==========================================
# üé• MOVIE RECOMMENDATION DATA PIPELINE PROJECT (FINAL FIXED CODE)
# ==========================================

# üì¶ STEP 1: Import Libraries
import pandas as pd
import matplotlib.pyplot as plt

# ==========================================
# üì• STEP 2: Load Datasets (FIXED for MovieLens 100k Local Files)
# ==========================================
# IMPORTANT: This assumes 'u.item' and 'u.data' have been uploaded to the Colab session.

movies_file = "u.item"
ratings_file = "u.data"

# Define columns for the pipe-delimited movie file (u.item)
movie_cols = ['movieId', 'title', 'release_date', 'video_release_date', 'IMDb_URL', 'unknown', 'Action', 'Adventure', 'Animation', 'Children', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy', 'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western']

# Define columns for the tab-delimited rating file (u.data)
rating_cols = ['userId', 'movieId', 'rating', 'timestamp']

try:
    # Load movie data (pipe-delimited, no header, latin-1 encoding)
    movies = pd.read_csv(movies_file, sep='|', names=movie_cols, encoding='latin-1')

    # Load rating data (tab-delimited, no header)
    ratings = pd.read_csv(ratings_file, sep='\t', names=rating_cols)

    # Keep only necessary columns for the merge
    movies = movies[['movieId', 'title']]
    ratings = ratings[['userId', 'movieId', 'rating', 'timestamp']]

    print("‚úÖ Data Loaded Successfully from local files!")
    print("Movies shape:", movies.shape)
    print("Ratings shape:", ratings.shape)

    # ==========================================
    # üßπ STEP 3: Merge and Preprocess
    # ==========================================
    movie_data = pd.merge(ratings, movies, on='movieId')
    # Drop the 'timestamp' column as it's not needed for the recommendation logic
    movie_data.drop('timestamp', axis=1, inplace=True)
    print("\n‚úÖ Sample Merged Data:")
    print(movie_data.head())

    # ==========================================
    # üß© STEP 4: Create User‚ÄìMovie Rating Matrix
    # ==========================================
    user_movie_matrix = movie_data.pivot_table(index='userId', columns='title', values='rating')
    print("\n‚úÖ User‚ÄìMovie Matrix Created")
    print("Matrix shape:", user_movie_matrix.shape)

    # ==========================================
    # üéØ STEP 5: Recommendation Function
    # ==========================================
    def recommend_movies(movie_name, min_ratings=50):
        """Generates movie recommendations using Pearson Correlation."""

        if movie_name not in user_movie_matrix.columns:
            print(f"‚ùå Movie '{movie_name}' not found in dataset. Check the exact title and year.")
            return None

        # Calculate correlation of the target movie with all other movies
        movie_ratings = user_movie_matrix[movie_name]
        similar_to_movie = user_movie_matrix.corrwith(movie_ratings)

        # Convert to DataFrame, drop NaNs (movies with no common users), and join rating count
        corr_movie = pd.DataFrame(similar_to_movie, columns=['Correlation'])
        corr_movie.dropna(inplace=True)

        ratings_count = movie_data.groupby('title')['rating'].count()
        corr_movie = corr_movie.join(ratings_count)
        corr_movie.rename(columns={'rating': 'Count'}, inplace=True)

        # Filter by minimum rating count, exclude the input movie, and sort by correlation
        recommendations = corr_movie[
            (corr_movie['Count'] >= min_ratings) & (corr_movie.index != movie_name)
        ].sort_values('Correlation', ascending=False)

        return recommendations.head(10)

    # ==========================================
    # üß† STEP 6: Example Recommendation
    # ==========================================
    movie_name = "Toy Story (1995)"
    min_ratings = 50
    print(f"\nüîç Generating recommendations for: '{movie_name}' (Min {min_ratings} ratings)\n")

    recommendations = recommend_movies(movie_name, min_ratings=min_ratings)
    print(recommendations)

    # ==========================================
    # üìä STEP 7: Visualization (Bar Chart)
    # ==========================================
    if recommendations is not None and not recommendations.empty:
        plt.figure(figsize=(10,6))
        # Plot in reverse order for highest correlation on top
        plt.barh(recommendations.index[::-1], recommendations["Correlation"][::-1], color="lightseagreen")
        plt.xlabel("Correlation Score", fontsize=12)
        plt.ylabel("Recommended Movies", fontsize=12)
        plt.title(f"üé¨ Top 10 Movies Similar to '{movie_name}' (Min {min_ratings} Ratings)", fontsize=14, fontweight='bold')
        plt.grid(axis='x', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show() # Display the chart

        # Save the chart to the Colab session
        plt.savefig("toy_story_recommendations_barchart.png")
        print("\n‚úÖ Bar Chart Generated and Saved as 'toy_story_recommendations_barchart.png'")
    else:
        print("‚ö†Ô∏è No recommendations to visualize.")

    # ==========================================
    # üíæ STEP 8: Save Recommendations
    # ==========================================
    if recommendations is not None:
        recommendations.to_csv("recommendations.csv", index=True)
        print("\nüíæ Recommendations saved as 'recommendations.csv'")

    print("\n‚úÖ Pipeline Execution Completed Successfully!")

except FileNotFoundError:
    print("\n‚ùå Error: Dataset files not found.")
    print("Please ensure you have uploaded 'u.item' and 'u.data' to your Google Colab session.")
except Exception as e:
    print(f"\n‚ùå Pipeline failed during execution. Error: {e}")

!wget http://files.grouplens.org/datasets/movielens/ml-100k/u.item
!wget http://files.grouplens.org/datasets/movielens/ml-100k/u.data